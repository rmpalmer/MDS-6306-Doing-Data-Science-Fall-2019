---
title: "Pre LiveSession 3"
author: "Richard Palmer"
date: "9/8/2019"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(GGally)
library(dplyr)
library(ggplot2)
library(purrr)
library(tidyr)

```

## Part 1

Load the data 
```{r}
fifa_raw <- read.csv("FIFA Players.csv")
```

Select two positions of interest and re-create the position factor with only those two

```{r}
fifa_lm_lf <- fifa_raw %>% filter(Position == 'LM' | Position == 'LF')
fifa_lm_lf$Position <- droplevels(fifa_lm_lf$Position)
fifa_lm_lf$Position %>% summary()
```

### Plot Acceleration and Agility versus Position
```{r}
fifa_lm_lf %>% select(Position,Acceleration,Agility) %>% ggpairs(aes(color=Position)) + ggtitle("Plot Accleration and Agility, separated by Position (LF or LM only)")
```

Acceleration and Agility are positively correlated.  The Left Forwards have higher higher median agility and acceleration.  There are a fair number of Mid fielders with low agility and acceleration.  We must be careful in the comparison, since there are many fewer (15) forwards than midfielders (1095)

### T-test

- Step 1 Hypotheses

H0: The mean of agility for left midfielders is the same as that for left forwards.
Ha: The mean of agility for left midfielders is different from that for left forwards.

- Step 2 The positive and negative Critical Values are:

```{r}
qt(c(.025, .975), df=nrow(fifa_lm_lf)-2) 
```

```{r}
lm_players <- fifa_raw %>% filter(Position == 'LM') 
lf_players <- fifa_raw %>% filter(Position == 'LF')
result <- t.test(lm_players$Agility, lf_players$Agility, var.equal = TRUE)
result
```

- Step 3 Test statistic is `r result[1]$statistic`

- Step 4 The p-value is `r result$p.value`

- Step 5 Fail to Reject the null hypothesis

- Step 6 Conclusion.  There is insufficient evidence to reject the null hypothesis that the LM and LF players have different mean agility values. A 95% confidence interval for the difference in mean agility is from `r result$conf.int[1]` to `r result$conf.int[2]`

### Are the assumptions met?

```{r}
```
- Random sampling.  We have nothing to indicate that the data are other than a random sampling.

- Normality / Equal variance

We will do Q-Q plots and histograms of Agility 

```{r}
fifa_lm_lf %>% filter(Position=="LM") %>%
 ggplot(aes(sample=Agility)) + stat_qq() + stat_qq_line() + ggtitle("Q-Q plot of Agility for LM")
fifa_lm_lf %>% filter(Position=="LF") %>%
 ggplot(aes(sample=Agility)) + stat_qq() + stat_qq_line() + ggtitle("Q-Q plot of Agility for LF")
fifa_lm_lf %>% filter(Position=="LM") %>% ggplot(aes(x=Agility)) + geom_histogram() + ggtitle("Histogram of Agility for LM") + xlim(40,100)
fifa_lm_lf %>% filter(Position=="LF") %>% ggplot(aes(x=Agility)) + geom_histogram() + ggtitle("Histogram of Agility for LF") + xlim(40,100)

```

The Q-Q plot for position LM shows some departure from Normality, and the histogram looks somewhat  normal.  Since there is a large number of observations, we will proceed.  For the LF position, there are far fewer observations, so we should proceed with caution.  It does appear that the distributions of the two positions have similar variance.

- independence.  For agility, there is no reason to believe that the players' values are not independent of one another.

## Part 2

Useful functions for EDA
```{r}
# function to convert height to numeric inches
to_inches <- function(height) {
  vals <- unlist(strsplit(x=height,split="'"))
  feet   <- as.numeric(vals[1])
  inches <-  as.numeric(vals[2])
  return (12*feet + inches)
}
# function to convert string weight to integer
to_pounds <- function(weight) {
  vals <- unlist(strsplit(x=weight,split="lbs"))
  lbs = as.numeric(vals[1])
  return (lbs)
}
# function to convert string to numeric value of euros
# nothing has a value 
to_euros <- function(value) {
  num <- sub(" ","",sub("K","000",sub("M","000000",sub("€","",value))))
  return(as.numeric(num))
}
```

Convert monetary fields as well as height and weight to numeric values
```{r}
fifa_all <- fifa_raw %>% rowwise() %>% 
  mutate(height_inches = to_inches(toString(Height)),
         weight_pounds = to_pounds(toString(Weight)),
         wage_euros    = to_euros(toString(Wage)),
         value_euros   = to_euros(toString(Value))) %>%
  mutate(log_wage = log(max(1,wage_euros)), 
         log_value = log(max(1,value_euros)))
```

Quick view of distributions of many continuous varibles.  

```{r}
fifa_all %>% keep(is.numeric) %>% gather() %>% ggplot(aes(x=value)) +geom_histogram() + facet_wrap(~key,scales="free") + geom_density()

```

Look more closely at Value versus Wage
```{r}
fifa_all %>% ggplot(aes(x=wage_euros,y=value_euros)) + geom_point() + ggtitle('Value versus Wage - absolute')

fifa_all %>% ggplot(aes(x=wage_euros,y=log_value)) + geom_point() + ggtitle("Log Value vs Wage")
```


What distinguishes the lower cloud of Value from the upper?

Look more closely at Value
```{r,echo=TRUE}
fifa_all %>% ggplot() + geom_histogram(aes(x=log_value)) + ggtitle("Histogram of Log Value")
```

What positions are of most value?

Mean Wage by nationality?
```{r,echo=TRUE}
fifa_wage = fifa_all %>% filter(!is.na(wage_euros) & !is.na(Nationality)) %>% group_by(Nationality) %>% summarise(mean_wage = mean(wage_euros)) %>% arrange(mean_wage) %>% print()
# order the nationalities
fifa_wage$Nationality <- factor(fifa_wage$Nationality,level=fifa_wage$Nationality[order(fifa_wage$mean_wage)])
# column plot of re-ordered results
fifa_wage %>% ggplot(aes(x=Nationality,y=mean_wage)) + geom_col() + ggtitle("Mean Wage by Nationality")
head(fifa_wage,10) %>% ggplot(aes(x=Nationality,y=mean_wage)) + geom_col() + ggtitle("Mean Wage by Nationality (low end)")
tail(fifa_wage,10) %>% ggplot(aes(x=Nationality,y=mean_wage)) + geom_col() + ggtitle("Mean Wage by Nationality (high end)")
```

it seems that there are three clusters of players by value
```{r}

fifa_all$value_class <- cut(fifa_all$log_value,breaks=c(0,7.5,14,20),labels=c("low","mid","high"))
```


```{r}
fifa_all %>% select(value_class,Agility,) %>% ggpairs(aes(color=value_class))
```

Mean Value by Position?
```{r,echo=TRUE}
fifa_value = fifa_all %>% filter(!is.na(value_euros) & !is.na(Position)) %>% group_by(Position) %>% summarise(mean_value = mean(value_euros)) %>% arrange(mean_value) %>% print()
# order the positions by value
fifa_value$Position <- factor(fifa_value$Position,level=fifa_value$Position[order(fifa_value$mean_value)])
# column plot of re-ordered results
fifa_value %>% ggplot(aes(x=Position,y=mean_value)) + geom_col() + ggtitle("Mean Value by position")
head(fifa_value,10) %>% ggplot(aes(x=Position,y=mean_value)) + geom_col() + ggtitle("Mean Value by Position (low end)")
head(fifa_value,10) %>% print()
tail(fifa_value,10) %>% ggplot(aes(x=Position,y=mean_value)) + geom_col() + ggtitle("Mean Value by Position (high end)")
tail(fifa_value,10) %>% print()
```

Mean Wage by position
```{r,echo=TRUE}
fifa_wage = fifa_all %>% filter(!is.na(wage_euros) & !is.na(Position)) %>% group_by(Position) %>% summarise(mean_wage = mean(wage_euros)) %>% arrange(mean_wage) %>% print()
# order the positions by wage
fifa_wage$Position <- factor(fifa_wage$Position,level=fifa_wage$Position[order(fifa_wage$mean_wage)])
# column plot of re-ordered results
fifa_wage %>% ggplot(aes(x=Position,y=mean_wage)) + geom_col() + ggtitle("Mean wage by position")
head(fifa_wage,10) %>% ggplot(aes(x=Position,y=mean_wage)) + geom_col() + ggtitle("Mean wage by Position (low end)")
head(fifa_wage,10) %>% print()
tail(fifa_wage,10) %>% ggplot(aes(x=Position,y=mean_wage)) + geom_col() + ggtitle("Mean wage by Position (high end)")
tail(fifa_wage,10) %>% print()
```

## Takeaways/Questions

### discovered new functions

Here is a very useful function from tidyr: gather()

gather() will convert a selection of columns into two columns: a key and a value. The key contains the names of the original columns, and the value contains the data held in the columns. If we don’t specify any arguments for gather(), it will convert ALL columns in our data frame into key-value pairs. 

And keep(), from purrr:

keep() will take our data frame (as the first argument/via a pipe), and apply a predicate function to each of its columns. Columns that return TRUE in the function will be kept, while others will be dropped. 

### Performance

I wonder how efficient dplyr is.  Am I making lots of copies of data in memory when I have a long string of functions connected by pipelines?

What steps should I take to make these analyses as efficient as possible?
